# Edit this at your own risk.

#==============================================================================
# â–  Mars_Core
#==============================================================================
module Mars_Core
	# TODO Make initialize crash or at least throw a warning
	
	## This should hold an instance of every inheritor of Mars_Rule_Base
	@@allRules = Array.new()
	
	## self.RegisterRule
	# Adds an instance of a rule object to the list of rules.
	#
	#		String newRule
	# The new rule object, which must inherit from Mars_Rule_Base
	#
	#		Returns:
	#	Nothing
	def self.RegisterRule(newRule)
		raise ArgumentError, "Cannot register rule unless rule inherits from Mars_Rule_Base" unless newRule.is_a?(Mars_Rule_Base)
		
		@@allRules = Array[newRule] + @@allRules
		
		#p(@@allRules)
	end
	
	## self.FindRule
	# Returns a rule which can answer to ruleName, if any.
	#
	#		string ruleName
	# Name of rule.
	#
	#		Returns:
	# Mars_Rule_Base	- Appropriate rule object to handle the rule
	# nil							- If no matching rule object could be found
	def self.FindRule(ruleName)
		return @@allRules.find{ |rule| rule.IsNamed?(ruleName) }
	end
	
	## self.ChooseAction
	# Attempts to select an action based on the given rules
	#
	#		Array<RPG::Enemy::Action> actions
	#	All possible actions to choose from.
	#	
	#		Array< <Array<String> > rules
	#	These are ALL of the rules for the current enemy that we are considering.
	#
	#		Returns:
	# RPG::Enemy::Action	- An action was determined
	# nil									- No action could be determined
	def self.ChooseAction(actions, rules)
		action = nil
		
		for rule in rules
			ruleHandler = FindRule(rule[0])
			
			# TODO Handle integers
			unless(ruleHandler.nil?)
				action = ruleHandler.ProcessRule(actions, rule)
				break
			end
		end
		
		return action
	end
	
	## interpret_notes
	# This interprets the notes of an enemy. It will load all of the Mars engine
	# rules for that enemy as separate arrays of strings.
	#
	# It will read lines under two conditions:
	#  1: The line starts with <mars>
	#  2: The line falls between lines with <mars-config> and <mars-end-config>
	#
	# However, in either case, empty lines are ignored. Also, all lines starting
	# with '#' are ignored. (NOTE THAT THIS DOES NOT APPLY TO '#' SYMBOLS AFTER
	# THE START OF THE LINE!)
	#
	#
	#		String notes
	# This is the enemy's "note" object. Just pass this directly in.
	#
	#	Returns:
	#		Array<Array<String>>
	# This table is the rules. It's formatted as one rule per outer index, and
	# then that rule's words per inner index.
	def self.interpret_notes(notes)
		found_mars_config_start = false
		rules = Array.new()	# Reinit the list; we don't want duplicates
		
		notes.each_line do |line|
			# Only process lines if we've found a mars config tag
			if(found_mars_config_start || line.downcase[/^<mars>/]) then
				if(line.downcase[/^<mars-end-config>/]) then
					found_mars_config_start = false
				else
					# Split the line into words
					words = line.scan(/[a-zA-Z0-9<>#]*/)
					words.reject! { |word| word == "" }
					words.reject! { |word| word.downcase[/<mars>/] }
					
					# Ignore comments and blank lines
					if(words[0] != "#" and words.size > 0) then
						# Add the line to our list of rules
						rules[rules.size] = words
					end
				end
			elsif(line.downcase[/^<mars-config>/]) then
				found_mars_config_start = true
			end
		end
		
		return rules
	end
	
end # class Mars_Core

